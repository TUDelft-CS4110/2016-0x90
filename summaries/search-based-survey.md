# Search-Based Software Test Data Generation
**Article:**
*Phil McMinn*. Search-Based Software Test Data Generation: A Survey. Software Testing, Verification and Reliability, vol. 14, no. 2, pp. 105â€“156, 2004.

## Metaheursitic Search Applications
**Goals:**
 - Coverage of the code.(note: e.g. SymJS)
 - Exercise a specific feature of the program.
 - Disprove grey-box properties.
 - Verify non-functional properties.

## Metaheursitic Search Techniques
Solution should be encoded such that they can be manipulated by the search and 'neighbours' can be compared. 
Using an *objective function*, the search decides *good* solutions from *bad* solutions and guides the search using this function.

### Hill Climbing
A local search algorithm that starts off at a random starting point and tries to look at neighbouring points in the search space to improve the solution.
Simple and fast, however often reaches sub-optimal solutions when there are many local optimal.
This can be 'patched' by starting at multiple random starting points.

### Simulated Annealing
Simulated Annealing is similar to Hill Climbing, but probabilistically accepts poorer solutions.
Starts off with lots of freedom in movement, but limits it more as the search progresses.

### Evolutionary Algorithms
#### Evolution Strategies
Evolution Strategies use mutation, a process of randomly modifying solutions. 
#### Genetic Algorithms
In Genetic Algorithms the search is driven by recombination, a mechanism of exchange of information between solutions to create new ones.
Genetic Algorithms keep track of a population of solutions, not just one solution. 
This allows sampling of a larger search space.
The population is combined a mutated to evolve successive populations.
Favour 'fitter' solutions to be combined and form even better solutions.
Choosing 'fitter' solutions too heavily can have a negative effect and reduce diversity and can cause premature convergence.

**Fitness-proprotionate selection:**
the number of times an individual is selected is proportional to its relative fitness.
Difficulties: maintaining a constant *selective pressure* (grade of selecting different solutions).

**Linear Ranking:**
individuals are sorted by fitness and a selective bias of *Z* is applied to each of the individuals.
This differs from fitness-proportionate selection in the sense that a constant bias is applied and thus the selective pressure is more constant and controlled.

**Tournament Selection:** 
two individuals are chosen at random, a random number is chosen and compared to the probability of the better individual being selected.
Afterwards the winner is the parent of the other individual.
Once all the parents have been selected, recombination forms the next generation.
Optionally random crossover is applied, sending children into a new population.
After the recombination, mutation is applied flipping random bits of binary strings with a certain probability.

#### Advanced Encodings and Operators
Problem in encoding: solutions can be close together, but their encoding can be very different.
Real-valued representations tend to outperform binary encodings and are used most often in Evolution Strategies.

## Structural (White-Box) Testing
White-Box Testing is the process of deriving tests from the internal structure of the software under test.

### Basic Concepts
*Read this section in the paper. Information is very high-density, which makes a summary useless.*

### Static Structural Test Data Generation
Data is generated by analysis of the internal without actually executing the program.

#### Symbolic Execution
Uses the process of assigning expressions to program variables as a path through the code structure to derive a constraint system in terms of the input variables which describe the conditions necessary for the traversal of a given path.

Backwards path traversal has an advantage over forward traversal in the sense that no storage is required for intermediate symbolic expressions of variables. Forward traversal however allows for early detection of infeasible paths.

Constraint satisfaction problems are NP-complete. However, combinations of heuristics and linear programming techniques can be applied to lighten the process.

Loops are executed *K* times, where *K* is specified by the tester or system.

Procedure calls can be inlined as a solution, however the number of paths can grow rapidly with this approach

#### Domain Reduction
*Constraint-based Testing* builds up a constraint system which describes the test goal. 
*Reachability constraints* withing the constraint system describe the conditions required for the reachability of statements.
*Necessity constraints* describe the conditions that will kill a mutant.

Using Symbolic Execution we can develop constraints in terms of input variables and perform *Domain Reduction*  to attempt a solution to the constraints. 
> Large search space ---constraints---> Reduction of search space

#### Dynamic Domain Reduction
Dynamic Domain Reduction is a static analysis technique that starts with domains of the input variables and reduce these dynamically during the symbolic execution stage in contrast to normal Domain Reduction. 

*This technique still suffers from difficulties with computed storage locations, loops and non-ordinal variable types(e.g. Enums).*

### Dynamic Structural Test Data Generation
*Dynamic methods* use some input to execute a program and uses instrumentation to observer the results.
Many of the issues regarding Symbolic Execution are resolved by directly resolving e.g. pointer values and array subscripts.

#### Random Testing
Executes the program with random inputs and observes executed program structures.
When using this technique, code that has low probability of being executed is often not covered, in such cases more directed search techniques are required.

##### Applying Local Search
In the Local Search technique, the tester selects a path through the program and produces a straight-line version of that path.
Path constraints are constructed with constant for each constraint estimating the satisfiability of the constraint.
A function *f* is constructed out of all of these constraints.
*f* provides an estimate of the satisfiability of all constraints.
Using numerical maximisation techniques, the input values are maximized to satisfy as many constraints as possible.
One major draw-back of this was that that run-time errors could occur, since the dependency between constraints were not take into acccount, which could create sequences, which in practice are impossible to execute.

Improvements to this technique emerged to resolve this problem.
The search was now targeted with the satisfaction of each constraint instead of all the constraints. 
If during the execution an undesired branch is take, a local search is started, that is targeted to minimize branch distance of the desired branch, also known as the *branch distance*.
Creating these inputs is done using the *alternating variable* method, that starts with an *exploratory phase* in which probes neighbouring constraints by increase or decreasing only that specific variable.
If the move leads to an improved objective value, a *pattern phase* is entered.
In this phase a larger move is made in the direction of the improvement, this is repeated until a minimum for that objective function is found for that variable.
After this is complete, other variable are explored.

These techniques suffer however from one main problem: the final solution is highly dependent on the starting solution, which can be very wasteful if unfavorable values are chosen.
A solution to this is the creation of an *influences graph*, that is created via dynamic data flow analysis and is used to detect which input variable influence the outcome at a branching node.
Additionally a risk analysis on the input variables can be performed to decided if they could violate the already successful sub-path.

##### The Goal-Oriented Approach
A Goal-Oriented Approach is a technique with a set goals(e.g. statement coverage).
Branches are prioritized by analyzing the control flow graph.

A branch is *critical*, when if chosen, the control flow won't reach the target node.
The objective function is then associated with the alternative branch.
The alternating variable search method is used, if the required inputs cannot be found, the process terminates with the target unexecuted.

A branch is *semi-critical* if it leads to a target node via the back edge of a loop. The alternative branch will lead directly to the target node.
Inputs for this are sought, but when they are not found, the alternative branch is iterated next.

A branch is *non-essential*, when it is neither *critical* nor *semi-critical*.
These branches do not effect the reachability of target node and are thus are allowed to be executed.

The Goal-Oriented Approach suffers from similar problems as the Local Search approach. The removal of the requirement to select a path introduces new ways in which the test data search can fail.
Instead of performing local searches, this technique can also use global search with Genetic Algorithms, but even these have their problems.

Main problem: data dependencies are not taken into account. An attempt to solve this solution is done in the Chaining Approach

##### The Chaining Approach
Chaining uses an *event sequence* as a intermediate means of deciding the type of path required to reach the target node. 
An *event sequence* is a succession of nodes that should be executed.
Initial sequence consists of *start* and *target* nodes.
This sequence is filled in once the test data search encounters difficulties.

**Event Sequence:** `<e_1, e_2, ... e_k>`, where `e_i = (n_i, C_i)` where `n_i in N` is a program node and `C_i` is a set of variables referred to as a constraint set.

Every two adjacent events should not have variables in the constraint set modified, this ensures that a *definition-clear path* must be taken from one node to the other node.

A branch is *critical* if there does not exist a definition-clear path between the two program nodes, even though such a path does exist via another branch.
A branch is *semi-critical* if it is not-critical, the target node is control dependent on path p and there does not exist an acyclic definition-clear path.
A branch is *non-essential* if it is none of the above.

When inputs cannot be found to change the flow of control such that a critical branch is avoided, the starting node is declared as being a problem node.
The technique then searches for alternative event sequences.

The Chaining Approach organises generate event sequences in a tree. 
The root being the initial event sequence and subsequent nodes are the resulting event sequences of all the corresponding problem nodes.
Backtracking techniques of depth *n* can be used in more complicated instances, to look for last definition statements of variables.
The tree is explored using a depth-first strategy, with a specified depth limit.
This technique covers a larger set of programs than the Goal-Oriented Approach, but as search times increase, local search can become trapped in difficult search spaces.

#### Applying Simulated Annealing
For the "neighbourliness" structure for integer and real variables is defined as the range of values around each individual value.
Boolean, enumerated types and all other order insignificant variables are considered as neighbours.
The objective function is the branch distance of the required branch when control flow diverges from the intended path. 
To reduce search becoming stuck in a local optima, the restriction that a solution must conform to an already existing sub-path is lifted.

#### Applying Evolutionary Algorithms
##### A Classification of Techniques
###### Coverage-Oriented Approaches
Coverage-Oriented Approaches work by rewarding on the basis of covered program structures.
Search tends to reward long paths through the test subject.
When using this technique, generally there is a lack of guidance provided for structures, which are only executed with values from a small portion of the overall input domain.
Therefore it is difficult to expect full coverage of these techniques for any non-trivial programs.

###### Structure-Oriented Approaches
Structure-Oriented Approaches take a *divide and conquer* approach to obtaining full coverage. In this approach, a separate search is done for each uncovered element.

**Branch-Distance-Oriented Approaches**: 
Branch-Distance-Oriented Approaches use branch predicates in combination with Random Search or Genetic Algorithms for the more difficult cases.
A path is chosen and the relevant branch predicates are extracted. A Genetic Algorithm is then used to find input data that satisfies all the branch predicates at once.
Since this technique requires rigid constraints, the chance of getting stuck in local optima is high.
It would be better if more feedback could be provided via the objective function.
This is where control oriented approaches come into play.

**Control-Oriented Approaches**:
in this technique, the objective function considers branching nodes that need to be executed to cover a desired structure.
This technique needs the control dependence graph of the test subject to identify each of these branching nodes.
The problem with the Control-Oriented Approach is that the objective function gives no guidance on how to change the flow of execution at control dependent nodes, since no distance information is exploited from branch predicates.

**Combined Approaches**
Combined Approaches make use of both branch distance and control information for the objective function.
The technique suffers a bit from local optima, but this can be resolved by using a form of *approximation level*.
The result looks quite a bit like the Control-Oriented approach, but by using branch distance calculations the objective function is greatly improved.

#### Objective Functions for Different Structural Coverage Criteria
Structural criteria are divided into four categories, where the general objective function is defined as: `approach_level + m_branch_dist`.
These two variables depends on the coverage type in question.

**Node-Oriented:**
Aim to cover specific nodes of the control flow graph.

**Path-Oriented:**
Require the execution of specific paths through the control flow graph.

**Node-Path-Oriented:**
Include branch coverage and LCSAJ (linear code sequence and jump) coverage.

**Node-Node-Oriented:**
Aim to execute a certain sequence of nodes through the control flow graph, without the specification of a concrete path between each node.

#### Control-Related Problems for Objective Functions
A major problem is covering nested structures within loops, which require a large number of iterations.
Some approaches try to resolve this by saying that the branches that miss the target in iterations of the loop as if they were critical branches.
However this leads to penalisation of individuals in the first iteration of the loop.

A second problem is the assignment of approach levels for some classes of programs with unstructured control flows.
A solution to this is to use *optimistic* or *pessimistic* approach level allocation strategies.
In an optimistic strategy, a control dependent branching node is allocated its approach level on the basis of the shortest control dependent path from itself to the target node.
In a pessimistic strategy, a branching node is allocated its approach level on the basis of the longest control dependent path to the target node.
Both strategies have different effects on the progress of the search, but it still remains an open problem as to which strategy works the best in general.

#### Branch-Distance-Related Problems for Objective Functions
The global search techniques still have some problems in hostile search landscapes containing large plateaux or several local optima.
Plateaux are for example really easily created by a simple "flag" variable.
With these types of flags, the evolutionary search performs no better than random search.

A solution to this is by removing a flag from the branch predicate by performing program transformation.
This is however not always possible.

Alternatively a sequence of nodes to be executed prior to the branch predicate containing the flag can be identified.
However, the approach has problems avoiding unrequired assignments to flags within loop bodies.

A second problem is that there exists the possibility that the branch distance calculation deceives the search.

A third problem can occur with nested branch predicates where a solution for subsequent conditions must be found without violating any of the earlier conditions.


